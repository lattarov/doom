* System setup
** TODO Setup script
Do a command to be run by the target system's package manager/other to install all necessary dependencies, set environment variables, etc.
** Security
*** Resources
- [[https://christitus.com/linux-security-mistakes/][The 3 Biggest Security Mistakes Linux Users Make]]
*** Setting up firewall
By default in most distros, the firewall is not active. In order to install it, install a firewall configuration tool (such as Firewall Configuration in debian-based distros), and do at least the following:

#+begin_src sh :tangle no
sudo ufw limit 22/tcp
sudo ufw allow 80/tcp
sudo ufw allow 443/tcp
sudo ufw default deny incoming
sudo ufw default allow outgoing
sudo ufw enable
#+end_src
*** Setting up [[https://github.com/fail2ban/fail2ban][fail2ban]]
fail2ban is a tool that will block repeated failing incoming connexions (particularly useful against brute force attacks) and can be installed via

#+begin_src sh :tangle no
sudo apt-get install fail2ban
#+end_src

The following default config file is recommended by the link in resources subsection

#+begin_src conf :tangle no
[DEFAULT]
ignoreip = 127.0.0.1/8 ::1
bantime = 3600
findtime = 600
maxretry = 5

[sshd]
enabled = true
#+end_src

The following will activate the systemd service:
#+begin_src sh :tangle no
sudo systemctl enable fail2ban
sudo systemctl start fail2ban
#+end_src
*** [[https://www.apparmor.net/][AppArmor]]
App to set behavioural profiled restrictions to apps running in this machine. It mainly targets Linux servers, but it can be a very powerful tool for security in desktop environment.

Configuration is not very straightforward according to reddit and forums...

to check if it's currently running, do
#+begin_src sh :tangle no
aa-status
#+end_src

if AppArmor is running, the following should be printed:

#+begin_quote
apparmor module is loaded.
#+end_quote

It's already preinstalled in !PopOS 22.04
*** NTSync module loading
The loadable module ntsync, available since kernel 6.14, greatly improves Windows emulated software performance. Though available, it is not loaded by default.

In order to load it at boot time, simply add

#+begin_quote
ntsync
#+end_quote

to [[/etc/modules]].


* Tasks
** DONE Add packages.el configuration here
** IDEA Add init.el configuration here
*** [?] how to know about new flags and updates for modules if init.el content is here?

* Compiling emacs :WIP:
** TODO full install procedure
#+begin_src sh :tangle no
# TODO log steps
# TODO fetch repos
# TODO verify checksum

JOBS=`nproc --ignore=1` # use almost all cores

# taken from
# https://gist.github.com/abidanBrito/2b5e447f191bb6bb70c9b6fe6f9e7956 for the rest
# https://www.reddit.com/r/emacs/comments/123klvf/emacs29_build_from_git_with_sqlite3/ (for sqlite3 error)
 ./autogen.sh && ./configure \
                             --with-dbus \
                             --with-native-compilation \
                             --with-tree-sitter \
                             --with-mailutils \
                             --with-pgtk \
                             --with-imagemagick \
                             --with-gif \
                             --with-jpeg \
                             --with-png \
                             --with-xml2 \
                             --with-tiff \
                             --with-libsystemd \
                             --with-modules \
                             --with-gnutls \
                             --with-x-toolkit=no \
                             CFLAGS="-O2 -pipe -mtune=native -march=native -fomit-frame-pointer"
                             --with-wide-int \

sudo make -j${JOBS} NATIVE_FULL_AOT=1

sudo make install
#+end_src

** Setting up systemd service
run the following command once:

#+begin_src bash :tangle no
systemctl --user enable --now emacs
#+end_src

If a restart is necessary, run

#+begin_src bash :tangle no
systemctl --user restart emacs
#+end_src

* Cross platform compatibility :wip:
#+begin_src emacs-lisp :tangle config.el

(defvar vlv-env-personal
  "PERSONAL"
  "Value set to vlv-env if in personal environment.")

(defvar vlv-env-work
  "WORK"
  "Value set to vlv-env if in work environment.")

(defcustom vlv-env vlv-env-personal
  "The current environment.

This will be used to activate or not certain functionalities
of this configuration, maily by tangling or not certain babel
code blocks.

TODO: replace this by a dedicated config for work once the doom
profiles API is stable.
"
  :type 'string
  :options '(vlv-env-personal vlv-env-work))

(if (eq system-type 'gnu/linux)
    (setopt vlv-env vlv-env-personal)
    (setopt vlv-env vlv-env-work))

(defun vlv-env-work ()
  "Returns t if in work environment, nil otherwise."
  (string-equal vlv-env vlv-env-work))

(defun vlv-env-personal ()
  "Returns t if in personal environment, nil otherwise."
  (string-equal vlv-env vlv-env-personal))

;; external doom dependencies in work environment
(when (vlv-env-work)
  (let* ((vlv-env-work-emacs-install-path  "c:/Emacs/")
         (vlv-env-work-runtimes-path       (expand-file-name "runtimes/"
                                                                     vlv-env-work-emacs-install-path))
         (vlv-env-work-runtimes-fd-path    (expand-file-name "fd"
                                                                     vlv-env-work-runtimes-path))
         (vlv-env-work-runtimes-rg-path    (expand-file-name "rg"
                                                                     vlv-env-work-runtimes-path))

         (vlv-env-work-cygwin-path         "C:/cygwin64")

         (vlv-env-work-cygwin-bin-path     (expand-file-name "bin"
                                                                     vlv-env-work-cygwin-path))


         (paths-to-add (list vlv-env-work-emacs-install-path
                             vlv-env-work-runtimes-path
                             vlv-env-work-runtimes-fd-path
                             vlv-env-work-runtimes-rg-path
                             vlv-env-work-cygwin-path
                             vlv-env-work-cygwin-bin-path)))

    ;; Add each existing path to `exec-path` and to the PATH env var
    (dolist (path paths-to-add)
      (let ((dir (directory-file-name (expand-file-name path))))
        (when (file-directory-p dir)
          ;; Add to Emacs' exec-path (used by call-process, etc.)
          (add-to-list 'exec-path dir)
          ;; Also add to the OS PATH environment so external tools can be found
          (setenv "PATH" (concat dir ";" (getenv "PATH"))))))))
#+end_src

* Doom
#+begin_src emacs-lisp :tangle config.el
;; frame
(add-to-list 'default-frame-alist '(alpha-background . 60))

;; welcome screen
(when (vlv-env-personal)
    (defun vlv/doom-dashboard-draw-ascii-banner-fn ()
        (let* ((banner
                '("██╗      █████╗ ████████╗████████╗ █████╗ ██████╗  ██████╗ "
                    "██║     ██╔══██╗╚══██╔══╝╚══██╔══╝██╔══██╗██╔══██╗██╔═══██╗"
                    "██║     ███████║   ██║      ██║   ███████║██████╔╝██║   ██║"
                    "██║     ██╔══██║   ██║      ██║   ██╔══██║██╔═██╚╗██║   ██║"
                    "███████╗██║  ██║   ██║      ██║   ██║  ██║██║ ███║███████╔╝"
                    "╚══════╝╚═╝  ╚═╝   ╚═╝      ╚═╝   ╚═╝  ╚═╝╚═╝ ╚══╝╚══════╝ "
                    "                                                           "
                    "                        E M A C S                          "
                    "                                                           "
                    "                                                           "
                    "                                                           "))
                (longest-line (apply #'max (mapcar #'length banner))))
            (put-text-property
            (point)
            (dolist (line banner (point))
            (insert (+doom-dashboard--center
                        +doom-dashboard--width
                        (concat
                        line (make-string (max 0 (- longest-line (length line)))
                                        32)))
                    "\n"))
            'face 'doom-dashboard-banner)))

    (setopt +doom-dashboard-ascii-banner-fn #'vlv/doom-dashboard-draw-ascii-banner-fn))

    ;; font
    (setopt doom-font (font-spec :family "Cascadia Code" :size 18))


    ;; make lookup online use eww insted of default browser.
    (setopt +lookup-open-url-fn 'eww)

    ;; clear SPC f p prefix to use in private config
    (map! :leader
        :prefix "f" "p" nil)

    (defun vlv-open-init-file ()
        "Opens the init.el file from private config."
        (interactive)
        (find-file (expand-file-name doom-module-init-file doom-user-dir)))

    (defun vlv-open-literate-config-file ()
        "Opens the config.org file from private config.

        NOTE we can't use +literate-config-file for it's not loaded
        until the user opens that file."
        (interactive)
        (find-file (expand-file-name "config.org" doom-user-dir)))

    (defun vlv-open-elfeed-file ()
        "Opens the elfeed feeds descriptor file from private config."
        (interactive)
        (find-file (expand-file-name "elfeed.org" doom-user-dir)))

    (map! :leader
        :prefix ("f p" . "Private config")
        :desc "Open init.el" "i" #'vlv-open-init-file
        :desc "Open elfeed.org" "e" #'vlv-open-elfeed-file
        :desc "Open literate config" "c" #'vlv-open-literate-config-file
        :desc "Browse" "p" #'doom/open-private-config)
#+end_src

** Checking for new modules
#+begin_src emacs-lisp :tangle no :results none
(let ((init-example-file (expand-file-name "static/init.example.el" doom-emacs-dir))
      (init-file          (expand-file-name "init.el" doom-user-dir)))
    (ediff-files init-file init-example-file))
#+end_src
*** IDEA create a hook in upgrade to discover new available modules

* Emacs general configs
** Personal information
#+begin_src emacs-lisp :tangle config.el
(setopt user-full-name    "Victor Lattaro Volpini"
        user-mail-address "victorlattaro@proton.me")
#+end_src

** Revert buffers when the underlying file has changed
#+begin_src emacs-lisp :tangle config.el
(setopt global-auto-revert-mode t

        ;; Revert Dired and other buffers
        global-auto-revert-non-file-buffers t)
#+end_src

** Editing
#+begin_src emacs-lisp :tangle config.el
(add-hook! 'prog-mode-hook 'olivetti-mode)
#+end_src

** Terminals (WIP)
this configures bash to be used as the default shell bash. In theory it corrects a few issues concerning

#+begin_src emacs-lisp :tangle no
;; Configuring terminal for windows
(if (eq system-type 'windows-nt)
        (setopt shell-file-name "C:/Windows/system32/bash.exe")
        (setenv "ESHELL" "bash")
 )
#+end_src
*** eshell
#+begin_src emacs-lisp :tangle config.el
(add-hook! 'eshell-mode-hook 'olivetti-mode)
#+end_src

** Emacs Lisp Mode
#+begin_src emacs-lisp :tangle config.el
(add-hook! 'emacs-lisp-mode-hook 'show-smartparens-mode)
#+end_src

* olivetti mode

#+begin_src emacs-lisp :tangle packages.el
(package! olivetti
  :pin "845eb7a95a3ca3325f1120c654d761b91683f598")
#+end_src

#+begin_src emacs-lisp :tangle config.el
(use-package! olivetti
  :defer t
  :config
  (setopt olivetti-body-width 120))
#+end_src

* Org
** Basic config
#+begin_src emacs-lisp :tangle config.el
(use-package! org
  :defer t
  :init
    (if (vlv-env-work)
          (setopt org-directory "~/OneDrive - Kestrel Vision/org")
          (setopt org-directory "~/org/"))

  :config
    (add-hook! 'org-mode-hook #'olivetti-mode
                              #'show-smartparens-mode)

    ;; babel
    (when (vlv-env-work)
    (setopt org-babel-C++-compiler "clang"
            org-babel-C-compiler   "clang")))
#+end_src
** Org agenda
*** Improvements
**** ideas from [[https://www.youtube.com/watch?v=a_WNtuefREM][Making Org Agenda Look Beautiful - YouTube]]
***** TODO  [[https://github.com/alphapapa/org-super-agenda][GitHub - alphapapa/org-super-agenda: Supercharge your Org daily/weekly agenda...]] integration
***** TODO add icons and improve agenda view using icons
***** TODO create templates for org roam to create events from nodes

*** Configuration
#+begin_src emacs-lisp :tangle config.el
(use-package! org-agenda
  :defer t
  :config
    (setopt org-journal-enable-agenda-integration t)

     ;; start on monday
    (setopt org-agenda-start-on-weekday 1)

    ;; add org-roam files to org-agenda-files
    (add-to-list 'org-agenda-files org-roam-directory))

;; in org agenda, the default behavior for leave all org-related buffers
;; opened. This is quite annoying given the number of buffers which can
;; in the order of the hundreds.
(map! :map org-agenda-mode-map "q" nil)
(map! :map org-agenda-mode-map
        :desc "Exit and close all buffers" "q" #'org-agenda-exit)
#+end_src
*** TODO Improve org-roam org-agenda performance

Ideas here: [[https://www.d12frosted.io/posts/2021-01-16-task-management-with-roam-vol5][Task management with org-roam Vol. 5: Dynamic and fast agenda - Boris Buliga]]


** Org Roam
Shortcuts are mapped with the SPC n r prefix by default.
#+begin_src emacs-lisp :tangle packages.el
(package! org-roam-ui
  :pin "5ac74960231db0bf7783c2ba7a19a60f582e91ab")
#+end_src

#+begin_src emacs-lisp :tangle config.el
(use-package! websocket
  :defer t
  :after org-roam)

(use-package! org-roam-ui
  :defer t
  :after org-roam ;; or :after org
  ;;         normally we'd recommend hooking orui after org-roam, but since org-roam does not have
  ;;         a hookable mode anymore, you're advised to pick something yourself
  ;;         if you don't care about startup time, use
  ;;  :hook (after-init . org-roam-ui-mode)
  :config
  (setopt org-roam-ui-sync-theme t
        org-roam-ui-follow t
        org-roam-ui-update-on-save t
        org-roam-ui-open-on-start t)
  ;; necessary use the org directory set on the
  (setopt org-roam-directory (expand-file-name "roam/" org-directory)))

(map! :leader
        (:prefix ("n" . "org")
        (:prefix ("r" . "roam")
         :desc "Open org roam UI" "u" #'org-roam-ui-mode)))
#+end_src
* Python
#+begin_src emacs-lisp :tangle config.el
(use-package! python
  :defer t
  :config
    (if (executable-find "ipython")
      (setopt python-shell-interpreter "ipython")
      (message "ipython not found in path. Using %s." python-shell-interpreter)))
#+end_src

** Conda
#+begin_src emacs-lisp :tangle config.el
(use-package! conda
  :defer t
  :config
  (setopt conda-anaconda-home (expand-file-name "~/miniconda3"))
  (setopt conda-env-home-directory (expand-file-name "~/miniconda3"))
  (conda-env-initialize-interactive-shells)
  (conda-env-initialize-eshell))
#+end_src
* uv :wip:
A new package manager for python, much faster and simpler to use than conda or miniconda.

#+begin_src emacs-lisp :tangle no

(package! uv-menu
  :type 'core
  :recipe '(:host github
            :repo "pizzatorque/uv-menu"
            :branch "main"
            :files ("uv.el")))

#+end_src

#+begin_src emacs-lisp :tangle no
(use-package! uv-menu
  :defer t)

#+end_src

* Projectile
Allow automatic recognition of projects given a list of paths.
#+begin_src emacs-lisp :tangle config.el
(use-package! projectile
  :defer t
  :config
    (setopt +workspaces-on-switch-project-behavior t)
    (setopt projectile-project-search-path '("~/dev"
                                             "D:/@Src")))
#+end_src

* Dired
#+begin_src emacs-lisp :tangle config.el
(use-package! dired
  :defer t
  :config
    (setopt dired-async-mode t))
#+end_src

* Dirvish
#+begin_src emacs-lisp :tangle config.el
(use-package! dirvish
  :defer t
  :config
  (setopt dirvish-quick-access-entries
          (let ((org-path (expand-file-name org-directory))
               (repos-path (if (vlv-env-work) "d:/@Src/" "~/dev/repos/")))
            `(("h" "~/" "Home")
              ("d" "~/Downloads/" "Downloads")
              ("D" "~/Documents/" "Documents")
              ("t" "c:/Tiama/" "Tiama")
              ("o" ,org-path "Org")
              ("r" ,repos-path "Repos")))))

(map! :leader
    (:prefix ("o" . "open")
    :desc "dirvish" "d" #'dirvish))
#+end_src

#+begin_src emacs-lisp :tangle config.el
(use-package! dirvish
  :defer t
  :config
  (transient-define-prefix vlv-dirvish-create ()
    "Transient menu to create new file or directory in dirvish."
    ["Create"
     ("d" "directory" dired-create-directory)
     ("f" "file" dired-create-empty-file)])

  ;; (map! :map dired-mode-map   :n "+" nil)
  ;; (map! :map dired-mode-map   :n "+" #'vlv-dirvish-create)
  (map! :map dirvish-mode-map :n "+" nil)
  (map! :map dirvish-mode-map :n "+" #'vlv-dirvish-create))
#+end_src

* YASNIPPET
#+begin_src emacs-lisp :tangle config.el
(use-package! yasnippet
  :defer t
  :config
    (defun yasnippet-extract-arg-and-type (arg)
    "Extract argument name and type from a string of the form 'arg: type'."
    (let* ((parts (split-string arg ": ")))
        (if (= (length parts) 2)
            (cons (car parts) (cadr parts))
        (cons (car parts) "type"))))

    (defun yasnippet-python-params-doc (arg-string)
    "Generates a docstring for parameters in NumPy style with optional type annotations.
    If there are no arguments, returns ''."
    (let* ((args (split-string arg-string ", "))
            (formatted-doc
            (if (string-blank-p arg-string)
                ""
                (mapconcat (lambda (arg)
                            (let* ((arg-pair (yasnippet-extract-arg-and-type arg))
                                    (arg-name (car arg-pair))
                                    (arg-type (cdr arg-pair)))
                            ;; TODO: Generate placeholders for each parameter description.
                            (format "%s : %s\n        TODO: Description of %s." arg-name arg-type arg-name)))
                        args
                        "\n    "))))
        formatted-doc))

    (defun yasnippet-python-parameter-assignments (arg-string)
    "Convert a comma-separated string of arguments into self assignments.
    If there are no arguments, returns 'pass'."
    (let* ((args (split-string arg-string ", "))
            (assignments
            (if (string-blank-p arg-string)
                "pass"
                (mapconcat (lambda (arg)
                            (let* ((parts (split-string arg ": "))
                                    (name (car parts)))
                            (format "self.%s = %s" name name)))
                        args
                        "\n        "))))
        assignments)))
#+end_src

** CC mode
*** LSP (clangd)
#+begin_src emacs-lisp :tangle config.el
(use-package! lsp-clangd
  :defer t
  :config
    (setopt lsp-clients-clangd-args
        '("-j=3"
          "--background-index"
          "--clang-tidy"
          "--completion-style=detailed"
          "--header-insertion=never"
          "--header-insertion-decorators=0"))
  (set-lsp-priority! 'clangd 2))
#+end_src
*** CMAKE-IDE
[[https://github.com/Fox7Fog/emacs-cmake-ide][GitHub - Fox7Fog/emacs-cmake-ide: Use Emacs as a C/C++ IDE]]
#+begin_src emacs-lisp :tangle packages.el
(package! cmake-ide
  :pin "28dc4ab5bd01d99553901b4efeb7234280928b18")
#+end_src

#+begin_src emacs-lisp :tangle config.el
(cmake-ide-setup)
#+end_src

*** TODO Fine tune LSP flags
* Large language model (LLM) support
To priviledge local usage of LLMs, we'll use [[https://ollama.com/][Ollama]] to run LLM models locally.

** ollama installation
Installation procedure is available in [[https://ollama.com/download/linux][Download Ollama on Linux]]:

#+begin_src sh :tangle no
curl -fsSL https://ollama.com/install.sh | sh
#+end_src

** GPTEL configuration
Set ollama as default backend for gptel, add default model and a few tweaks.

#+begin_src emacs-lisp :tangle config.el
(use-package! gptel
  :defer t
  :config
    (add-hook! 'gptel-post-stream-hook 'gptel-auto-scroll)

    (add-hook! 'gptel-post-response-functions 'gptel-end-of-response)

    (setopt gptel-model 'deepseek-r1:8b)

    (setopt vlv--gptel-ollama (gptel-make-ollama "ollama"
                                :host "localhost:11434"
                                :stream t
                                :models '((deepseek-coder-v2:16b)
                                        (ifioravanti/llamantino-2)
                                        (deepseek-r1:8b)
                                        (deepseek-r1:7b))))

    (setopt vlv--gptel-copilot (gptel-make-gh-copilot "copilot"))

    (setopt gptel-backend vlv--gptel-ollama))
#+end_src

** Auggie (Augment Code CLI) via agent-shell :WIP:
Auggie is the Augment Code CLI that provides AI-powered coding assistance via the Agent Client Protocol (ACP).
This integrates agent-shell.el to use Auggie alongside gptel backends.

Prerequisites:
- Install Auggie CLI: https://docs.augmentcode.com/cli/setup-auggie/install-auggie-cli
- Login to Augment: =auggie login=

#+begin_src emacs-lisp :tangle packages.el
;; agent-shell and its dependencies for Auggie CLI integration
(package! shell-maker)
(package! acp)
(package! agent-shell)
#+end_src

#+begin_src emacs-lisp :tangle config.el
;; Load local Auggie configuration
(add-to-list 'load-path (expand-file-name "auggie" doom-user-dir))

(use-package! acp
  :defer t)

(use-package! agent-shell
  :defer t
  :after acp
  :config
  ;; Load Auggie configuration and add it to available agents
  (require 'auggie-config)
  (add-to-list 'agent-shell-agent-configs (auggie-make-config)))

;; Keybindings for AI assistants (gptel and Auggie)
(map! :leader
      :prefix ("l" . "+LLM/AI")
      :desc "Select AI assistant" "l" #'auggie-or-gptel
      :desc "Start Auggie" "a" #'auggie-start
      :desc "Start gptel" "g" #'gptel
      :desc "gptel menu" "m" #'gptel-menu
      :desc "Send region to Auggie" "r" #'auggie-send-region
      :desc "Send buffer to Auggie" "b" #'auggie-send-buffer
      :desc "gptel send" "s" #'gptel-send)
#+end_src

* bug-hunter
#+begin_src emacs-lisp :tangle packages.el
(package! bug-hunter)
#+end_src

* elfeed

#+begin_src emacs-lisp :tangle config.el
(use-package! elfeed
  :defer t
  :config
    ;; the basic value cuts a part of the feed's title.
    ;; Increasing the column width fixes it.
    (setopt elfeed-goodies/feed-source-column-width 25)


    ;; Strangely, elfeed does not allow us to delete entries that we don't want to see
    ;; in the feed anymore. Moreover, when a feed is deleted, its entries are not
    ;; removed from the feed.

    ;; A solution is proposed by https://github.com/skeeto/elfeed/issues/392, it works
    ;; by deleting selected items feed from elfeed's database.

    (defun sk/elfeed-db-remove-entry (id)
      "Removes the entry for ID"
      (avl-tree-delete elfeed-db-index id)
      (remhash id elfeed-db-entries))

    (defun sk/elfeed-search-remove-selected ()
      "Remove selected entries from database"
      (interactive)
      (let* ((entries (elfeed-search-selected))
              (count (length entries)))
          (when (y-or-n-p (format "Delete %d entires?" count))
          (cl-loop for entry in entries
                  do (sk/elfeed-db-remove-entry (elfeed-entry-id entry)))))
      (elfeed-search-update--force))

    (add-hook! 'elfeed-show-mode-hook 'olivetti-mode))

(map! :leader
    (:prefix ("e" . "elfeed")
    :desc "Enter elfeed" "e" #'elfeed
    :desc "Update all feeds" "u" #'elfeed-update))

;; copy elfeed.org to the org directory. Put here so that the elfeed.org
;; is tangled whenever doom-reload is run.

(when (vlv-env-personal)
  (copy-file (expand-file-name "elfeed.org" doom-user-dir) org-directory t))
#+end_src

* Consult :wip:
** Consult-omni
[[https://github.com/armindarvish/consult-omni?tab=readme-ov-file#drop-in-example-config][GitHub - armindarvish/consult-omni: A Powerful Versatile Omni Search inside E...]]

"consult-omni is a package for getting search results from one or several custom
sources (web search engines, AI assistants, elfeed database, org notes, local
files, desktop applications, mail servers, …) directly in Emacs minibuffer. It
is a successor of consult-web, with expanded features and functionalities."

It still in its beta phase, having its first release in July 24'.

Some security concerns arise due to using emacs as a web browser... This is to
be tested and tracked over time. The project seems nevertheless extremely
promising and would bring plenty of nice features to the config.


#+begin_src emacs-lisp :tangle packages.el
(package! consult-mu
  :recipe '(:host github
            :repo "armindarvish/consult-mu"
            :files (:defaults "extras/*.el")))
#+end_src

#+begin_src emacs-lisp :tangle config.el
(use-package! consult-mu
  :defer t
  :custom

  ;;maximum number of results shown in minibuffer
  (consult-mu-maxnum 200)
  ;;show preview when pressing any keys
  (consult-mu-preview-key 'any)
  ;;do not mark email as read when previewed
  (consult-mu-mark-previewed-as-read nil)
  ;;do not amrk email as read when selected. This is a good starting point to ensure you would not miss important emails marked as read by mistake especially when trying this package out. Later you can change this to t.
  (consult-mu-mark-viewed-as-read nil)
  ;; open the message in mu4e-view-buffer when selected.
  (consult-mu-action #'consult-mu--view-action))
#+end_src

#+begin_src emacs-lisp :tangle packages.el
(package! consult-omni
  :type 'core
  :recipe '(:host github
            :repo "armindarvish/consult-omni"
            :files ("sources/*.el" "consult-omni.el" "consult-omni-embark.el")
            :build t))
#+end_src

#+begin_src emacs-lisp :tangle config.el
(use-package! consult-omni
  :defer t
  :custom

  ;; General settings that apply to all sources
  (consult-omni-show-preview t) ;;; show previews
  (consult-omni-preview-key "C-o") ;;; set the preview key to C-o
  :config
  ;; Load Sources Core code
  (require 'consult-omni-sources)
  ;; Load Embark Actions
  (require 'consult-omni-embark)

  ;;; Select a list of modules you want to aload, otherwise all sources all laoded
  (setopt consult-omni-sources-modules-to-load (list 'consult-omni-notes  'consult-omni-file 'consult-omni-buffer 'consult-omni-buffer-search 'consult-omni-elfeed 'consult-omni-wikipedia 'consult-omni-apps 'consult-omni-dictionary 'consult-omni-gptel 'consult-omni-youtube))

  (consult-omni-sources-load-modules)
  ;;; set multiple sources for consult-omni-multi command. Change these lists as needed for different interactive commands. Keep in mind that each source has to be a key in `consult-omni-sources-alist'.
  (setopt consult-omni-multi-sources '("calc"
                                     "File"
                                     "Buffer"
                                     ;; "DuckDuckGo"
                                     ;; "Bookmark"
                                     "Apps"
                                     "gptel"
                                     ;; "Brave"
                                     "Dictionary"
                                     ;; "Google"
                                     "Wikipedia"
                                     "elfeed"
                                     ;; "mu4e"
                                     "buffers text search"
                                     "Notes Search"
                                     "Org Agenda"
                                     ;; "GitHub"
                                     "YouTube"
                                     ;; "Invidious"
                                     ))

;; Per source customization

;;; Set your shorthand favorite interactive command
 (setopt consult-omni-default-interactive-command #'consult-omni-multi))
:bind
  (map! :leader
        (:prefix ("s" . "search")
         :desc "consult-omni-multi" "s" #'consult-omni-multi))
#+end_src
*** YouTube search API
#+begin_src emacs-lisp :tangle config.el
(setopt consult-omni-youtube-search-key "AIzaSyAMbCC2_BQRaGifhK2tVifSOTCwucT9Lao")
#+end_src
**** TODO Encrypt

** bindings
#+begin_src emacs-lisp :tangle config.el
(map! :leader
      :prefix "s"
      :desc "consult-ripgrep" "R" #'consult-ripgrep)

(map! :leader
      :prefix "s"
      :desc "consult-kill-ring" "c" #'consult-yank-from-kill-ring)
#+end_src

* Mail
** Mu4e
*** WARNING Installation error pitfall
Because of some Ubuntu based bug, if mu4e was installed by the package manager (APT in Pop OS case) then the following bug shows up:

#+begin_quote
execute-extended-command: Cannot open load file: No such file or directory, mu4e
#+end_quote

As recommended in doom's mu4e docs as well as in [[https://github.com/doomemacs/doomemacs/issues/7885][doomemacs/doomemacs#7885 Can't open mu4e]] , manually adding the load path fixes this.

#+begin_src emacs-lisp :tangle config.el
(add-to-list 'load-path "/usr/share/emacs/site-lisp/mu4e")
#+end_src

But different bugs arise, apparently related to a header error in mu4e or something else. It seems that the mu version installed by apt is not really functional.

**** Mu4e
WARNING there's a hard dependency between mu and mu4e versions.
#+begin_src sh :tangle no
sudo apt-get install mu4e
#+end_src

In order to set the mail directory and do the first setup for mu's database, use the following command:


*** Dependencies
**** mbsync (aka isync)
#+begin_src sh :tangle  no
sudo apt-get install isync
#+end_src

mbsync also requires a config file (by default .mbsyncrc) to be placed in the home directory. See each mail provider's section for more information.


Next, the mail directory, or MailDir in mu's vocabulary. By default, it's a ~/Mail, which is not automatically created. Let's do so:

#+begin_src sh :tangle no
mkdir ~/Mail
#+end_src

finally, the following command pulls the mail from the given provider:

#+begin_src sh :tangle no
mbsync -Va
#+end_src

***** GMail

#+begin_src ini :tangle no
IMAPStore gmail-remote
Host imap.gmail.com
SSLType IMAPS
AuthMechs LOGIN
User victorlattaro@gmail.com
Pass "epcw alkb kynv svai"

MaildirStore gmail-local
Path ~/Mail/gmail/
Inbox ~/Mail/gmail/INBOX
Subfolders Verbatim

Channel gmail
Master :gmail-remote:
Slave :gmail-local:
Create Both
Expunge Both
Patterns *
SyncState *
#+end_src
****** TODO Encrypt password

***** TODO Proton
- needs a paid account and the proton bridge daemon installed.
- running this in the background can eat up A LOT of memory, this is to be tested before going forward.
***** TODO Outlook

**** mu
***** Setup and installation

****** Option 1: build from source

The solution was to manually compile mu and install it by following instructions in [[github:https://github.com/djcb/mu][mu]].

According to the README:

To be able to build mu, ensure you have:

a C++17 compiler (gcc or clang are known to work)
development packages for Xapian and GMime and GLib (see meson.build for the versions)
basic tools such as make, sed, grep
meson

clone somewhere the latest release from mu, I used https://github.com/djcb/mu/releases/tag/v1.12.7
(this version already comes with mu4e)


******* Dependencies
#+begin_src sh :tangle no
sudo apt-get install meson libgmime-3.0-dev libxapian-dev
#+end_src

cd wherever mu release tarball was decompressed and

#+begin_src sh :tangle no
./autogen.sh && make
sudo make install
#+end_src

The tarball contains mu and mu4e.

****** Option 2: Install with package manager

WARNING there can be mismatches between mu and mu4e!
#+begin_src sh :tangle no
sudo apt-get install mu4e
#+end_src


***** Init and index mail in maildir
Create the Maildir, in this config it is set to ~/Mail and run

#+begin_src sh :tangle no
mu init --maildir ~/Mail
mu index
#+end_src

if mu4e is not found in Emacs, add the path (probably the one below to the load-path)


From this point onwards, mu4e should be up and running.
*** Configuration

#+begin_src emacs-lisp :tangle config.el
(use-package! mu
  :defer t
  :if (vlv-env-personal)
  :init
  ;; installation path for mu4e installed by the makefile (manual compiled)
    (add-to-list 'load-path "/usr/local/share/emacs/site-lisp/mu4e")

    ;; apt-based installation
    (let* ((mu-version-command               "mu --version")
        (mu-version-command-output-prefix "version ")
        (mu-version-command-output        (shell-command-to-string mu-version-command))
        (mu4e-target-version              (string-trim (string-remove-prefix
                                                            mu-version-command-output-prefix
                                                            mu-version-command-output)))
        (mu4e-target-path-base            "/usr/share/emacs/site-lisp/elpa-src/mu4e-")
        (mu4e-load-path                   (concat mu4e-target-path-base
                                                    mu4e-target-version)))
    ;; check if directory exusts
    (if (file-directory-p mu4e-load-path)
        (add-to-list 'load-path mu4e-load-path)
        (error "Path to mu4e does not exist: %s. \n Potential version mismatch between mu and mu4e"
            mu4e-load-path)))

    ;; setting up accounts
    (set-email-account! "@gmail.com"
    '((mu4e-sent-folder       . "/gmail/Sent Mail")
        (mu4e-drafts-folder     . "/gmail/Drafts")
        (mu4e-trash-folder      . "/gmail/Trash")
        (mu4e-refile-folder     . "/gmail/All Mail")
        (smtpmail-smtp-user     . "victorlattaro@gmail.com")
        (mu4e-compose-signature . "---\nVictor Lattaro Volpini")))
    ;; if "gmail" is missing from the address or maildir, the account must be
    ;; specified manually in `+mu4e-gmail-accounts':
    (setopt +mu4e-gmail-accounts '(("victorlattaro@gmail.com" . "/victorlattaro")))

    ;; Each path is relative to the path of the maildir you passed to mu
    (setopt mu4e-index-cleanup nil
            ;; because gmail uses labels as folders we can use lazy check since
            ;; messages don't really "move"
            mu4e-index-lazy-check t))
#+end_src

* Copilot :wip:

17/01/25 - The package breaks A LOT of stuff in Windows, breaks LSP integration (currently using LSP-mode) and server needs to be reinstalled quite often.
#+begin_src emacs-lisp :tangle no
(package! copilot
  :recipe (:host github :repo "copilot-emacs/copilot.el" :files ("*.el")))
#+end_src

#+begin_src emacs-lisp :tangle no
;; accept completion from copilot and fallback to company
(use-package! copilot
  :defet t
  :hook (prog-mode . copilot-mode)
  :bind (:map copilot-completion-map
              ("<tab>" . 'copilot-accept-completion)
              ("TAB" . 'copilot-accept-completion)
              ("C-TAB" . 'copilot-accept-completion-by-word)
              ("C-<tab>" . 'copilot-accept-completion-by-word)))

#+end_src

* Work
** TightVNC
*** Transient menu :WIP:
#+begin_src emacs-lisp :tangle config.el
(require 'transient)
(defvar vlv/vnc-machines
    '(("VISIO"            . "10.4.54.221")
      ("VERN"             . "10.102.31.63")
      ("CMX"              . "10.4.54.223")
      ("CXP"              . "10.4.54.224")
      ("Gamora"           . "10.4.52.13")
      ("Groot"            . "10.4.52.9" )
      ("Rocket"           . "10.4.52.11")
      ("Mantis"           . "10.4.52.17")
      ("Starlord"         . "10.4.52.3")
      ("BDT-INCA10-VERN"  . "10.102.31.64"))
    "Alist mapping machine names to their TightVNC IPs.")

(defvar vlv/vncviewer-path "C:/Program Files/TightVNC/tvnviewer.exe"
    "Path to the TightVNC client.")

(defvar vlv/vnc-password "ADMINVME"
    "Default password.")

(defun vlv/connect-to-vnc-with-machine (machine)
    "Connect to a given machine via VNC given it's name."
    (let ((ip (cdr (assoc machine vlv/vnc-machines))))
    (message ip)
    (if (and ip (file-exists-p vlv/vncviewer-path))
            (start-process "tightvnc" nil vlv/vncviewer-path ip (concat "-password=" vlv/vnc-password))
    (message "Error: Wrong path to TightVNC or bad password!"))))

(defun vlv/connect-to-vnc-with-ip (ip)
    "Conectar ao VNC na máquina IP."
    (if (and ip (file-exists-p vlv/vncviewer-path))
        (start-process "tightvnc" nil vlv/vncviewer-path ip (concat "-password=" vlv/vnc-password))
    (message "Error: Failed to launch TightVNC")))

(defun vlv/vnc-menu-items ()
    "Return a list of transient menu items for VNC machines."
    (mapcar (lambda (pair)
            (list (substring (car pair) 0 1) (car pair)
                    (lambda () (interactive) (vlv/connect-to-vnc (car pair)))))
            vlv/vnc-machines))

(transient-define-prefix vlv/vnc-menu ()
"Transient menu for selecting a TightVNC machine."
    [["Machines"
    ("a" "VISIO"             (lambda () (interactive) (vlv/connect-to-vnc-with-machine "VISIO")))
    ("z" "VERN"              (lambda () (interactive) (vlv/connect-to-vnc-with-machine "VERN")))
    ("e" "CMX"               (lambda () (interactive) (vlv/connect-to-vnc-with-machine "CMX")))
    ("r" "CXP"               (lambda () (interactive) (vlv/connect-to-vnc-with-machine "CXP")))
    ("t" "BDT-INCA10-VERN"   (lambda () (interactive) (vlv/connect-to-vnc-with-machine "BDT-INCA10-VERN")))
    ("s" "STARLORD"          (lambda () (interactive) (vlv/connect-to-vnc-with-machine "STARLORD")))
    ("o" "Choose IP:"        (lambda () (interactive) (vlv/connect-to-vnc-with-ip  (read-string "IP:"))))]])

(map! :prefix "C-c" :desc "TightVNC menu" "v" #'vlv/vnc-menu)
#+end_src

** Visual Studio
#+begin_src emacs-lisp tangle config.el
(defun vlv/find-and-open-sln-in-visual-studio ()
  "Find all .sln files in the current Projectile project and open one in Visual Studio at the current buffer's file."
  (interactive)
  (let* ((project-root (projectile-project-root))
         (sln-files (directory-files-recursively project-root "\\.sln$"))
         (current-file (buffer-file-name)))
    (if (null sln-files)
        (error "No .sln files found in the project."))
      (let ((chosen-sln (if (= (length sln-files) 1)
                            (car sln-files)
                          (completing-read "Choose a solution: " sln-files nil t))))
            (let* ((command (format "start devenv \"%s\"" chosen-sln)))
              (message "Running: %s" command)
              (start-process-shell-command "open-sln" nil command)))))

(map! :leader
      :prefix "o"
      :desc "Find project SLN and open Visual Studio" "s" #'vlv/find-and-open-sln-in-visual-studio)
#+end_src
** Wind River Workbench

#+begin_src emacs-lisp :tangle config.el
(defcustom vlv--workbench3-path
  "C:/WindRiver_6947/workbench-3.3/wrwb/platform/x86-win32/eclipse/wrwb-x86-win32.exe"
  "The path to the executable or script to start WindRiver 3 workbench IDE."
  :type 'file
  :group 'work)

(defcustom vlv--workbench4-path
  "~/dev/repos/089-VXWORKS_CALIA4/workbench-4/startWorkbench.bat"
  "The path to the executable or script to start WindRiver 4 workbench IDE."
  :type 'file
  :group 'work)

(defun vlv/open-windriver3-workbench ()
  "Open Wind River Workbench 3 IDE."
    (interactive)
    (start-process "workbench" nil vlv--workbench3-path))

(defun vlv/open-windriver4-workbench ()
  "Open Wind River Workbench 4 IDE."
    (interactive)
    (start-process "workbench" nil vlv--workbench4-path))


(map! :leader
      :prefix "o"
      :desc "WindRiver Workbench 3" "W" #'vlv/open-windriver3-workbench)

(map! :leader
      :prefix "o"
      :desc "WindRiver Workbench 4" "w" #'vlv/open-windriver4-workbench)
#+end_src

** consult-everything (windows)

#+begin_src emacs-lisp :tangle packages.el
(package! consult-everything
  :pin "ac574a63b3e869787bbe6354b57a7a8021647ee3"
  :recipe '(:host github
            :repo "jthaman/consult-everything"
            :build t))
#+end_src

#+begin_src emacs-lisp :tangle config.el
(use-package! consult-everything
  :defer t)

(map! :leader
      :prefix "s"
      :desc "consult-everything" "E" #'consult-everything)
#+end_src
** Tree-sitter
#+begin_src emacs-lisp :tangle config.el
(use-package! treesit
  :defer t
  :config
  ;; if auto, it'll prompt for installation at every file, at every session...
  (setopt treesit-auto-install-grammar nil))
#+end_src

*** Grammars
Download or compile grammars and add them to a subdirectory in C:/Tiama/ (to avoid false AV warnings and blockers) and symlink it to *treesit--install-language-grammar-out-dir-history*.

In this case, the source directory is *c:/Tiama/tree-sitter*.

#+begin_src
mklink /D "c:/Users/LATTARO-VOLPINI/.config/emacs/.local/cache/tree-sitter" "c:/Tiama/tree-sitter"
#+end_src

* Compiler explorer
#+begin_src emacs-lisp :tangle packages.el
(package! compiler-explorer
  :pin "efad3b9f92098d2eb28d6ae47b71e8853f6dfb49"
  :recipe '(:host github
            :repo "mkcms/compiler-explorer.el"
            :build t))
#+end_src

#+begin_src emacs-lisp :tangle config.el
(use-package! compiler-explorer
  :defer t)

(map! :leader
      :prefix "o"
      :desc "Compiler Explorer (GodBolt)" "c" #'compiler-explorer)
#+end_src
* DevDocs.el
#+begin_src emacs-lisp :tangle packages.el
(package! devdocs
  :pin "25c746024ddf73570195bf42b841f761a2fee10c")
#+end_src

#+begin_src emacs-lisp :tangle config.el
(use-package! devdocs
  :defer t)

(map! :leader
      :prefix ("s" . "+search")
      :desc "devdocs-lookup"
      "d" #'devdocs-lookup)
#+end_src
* Spotify
#+begin_src emacs-lisp :tangle packages.el
(package! spotify
  :disable (not (eq system-type 'gnu/linux))
  :pin "d918b5187638e0c44a2a2584f3980244b6aae3fa")
#+end_src

#+begin_src emacs-lisp :tangle config.el
(use-package! spotify
  ;; WARNING using "defer t" makes the package not be loaded when using bindings.
  :config
    (defun vlv/spotify-next-and-display()
    "Plays the next song and displays it's author, name and album."
    (interactive)
    (spotify-next)
    (call-interactively 'spotify-current))

    (defun vlv/spotify-previous-and-display()
    "Plays the previous song and displays it's author, name and album."
    (interactive)
    (spotify-previous)
    (call-interactively 'spotify-current))

    (defun vlv/spotify-playpause-and-display()
    "Toggles pause and displays it's author, name and album."
    (interactive)
    (spotify-playpause)
    (call-interactively 'spotify-current)))

(map! :leader
        (:prefix ("v" . "perso")
        :desc "spotify-play/pause" "p" #'vlv/spotify-playpause-and-display
        :desc "spotify-previous" "P" #'vlv/spotify-previous-and-display
        :desc "spotify-open" "q" #'spotify-quit
        :desc "spotify-next" "n" #'vlv/spotify-next-and-display))
#+end_src
* vterm
Found an interesting completion mechanism in [[https://www.reddit.com/r/emacs/comments/ovkyov/vterm_completion_for_files_directories_command/][this reddit post]] and it considerably improves usage.

#+begin_src emacs-lisp :tangle config.el
(use-package! vterm
  :defer t
  :config
  (defun get-full-list ()
    (let ((program-list (split-string (shell-command-to-string "compgen -c") "\n" t ))
          (file-directory-list (split-string (shell-command-to-string "compgen -f") "\n" t ))
          (history-list (with-temp-buffer
                          (insert-file-contents "~/.bash_history")
                          (split-string (buffer-string) "\n" t))))

      (delete-dups (append program-list file-directory-list history-list))))

  (defun vterm-completion-choose-item ()
    (completing-read "Choose: " (get-full-list) nil nil (thing-at-point 'word 'no-properties)))

  (defun vterm-completion ()
    (interactive)
    (vterm-directory-sync)
    (setopt vterm-chosen-item (vterm-completion-choose-item))
    (when (thing-at-point 'word)
      (vterm-send-meta-backspace))
    (vterm-send-string vterm-chosen-item))

  (defun vterm-directory-sync ()
    "Synchronize current working directory."
    (interactive)
    (when vterm--process
      (let* ((pid (process-id vterm--process))
             (dir (file-truename (format "/proc/%d/cwd/" pid))))
        (setopt default-directory dir))))

  :general
  (:states 'insert
           :keymaps 'vterm-mode-map
           "<tab>" 'vterm-completion))



#+end_src

* multi-vterm
#+begin_src emacs-lisp :tangle packages.el
(package! multi-vterm
  :pin "36746d85870dac5aaee6b9af4aa1c3c0ef21a905")
#+end_src

#+begin_src emacs-lisp :tangle config.el
(use-package! multi-vterm
  :defer t)
#+end_src

* Emacs Application Framework EAF :WIP:

#+begin_src emacs-lisp :tangle no

(package! eaf
  :recipe '(
    :host github
    :repo "emacs-eaf/emacs-application-framework"
    :files ("*.el" "*.py" "core" "app" "*.json")
    :includes (eaf-browser) ; Straight won't try to search for these packages when we make further use-package invocations for them
    :pre-build '(("python" "install-eaf.py" "--install" "browser" "--ignore-sys-deps"))))
#+end_src

#+begin_src emacs-lisp :tangle no
(add-load-path! "~/.config/emacs/.local/straight/repos/emacs-application-framework")
(require 'eaf-browser)
#+end_src

* Whisper

Whisper.el is a package that allows voice to text transcription in Emacs. It needs a few dependencies, namely
 - [[https://ffmpeg.org/][FFmpeg]]: "A complete, cross-platform solution to record, convert and stream audio and video."
   Can be installed using
   #+begin_src sh :tangle no
sudo apt-get install ffmpeg
   #+end_src
 - [[https://github.com/ggml-org/whisper.cpp][whisper.cpp]]: Port of OpenAI's Whisper model in C/C++
   Is fetched and compiled by running whisper. Needs git, a C++ compiler and CMake.

#+begin_src emacs-lisp :tangle packages.el
(package! whisper.el
  :pin "6198ce3d9bff0555cf098a77b78d6c2d79baf4f9"
  :recipe '(
    :host github
    :repo "natrys/whisper.el"))
#+end_src


#+begin_src emacs-lisp :tangle config.el
(use-package! whisper.el
  :defer t ;; A configuration error appears if the fur is not set.
  :config
    (setopt whisper-install-directory "/tmp/"
            whisper-model "base"
            whisper-language "en"
            whisper-translate nil
            whisper-use-threads (/ (num-processors) 2))

    (defun vlv/call-whisper-run-print-language ()
        (minibuffer-message
            (concat
                "Calling whisper-run with language: " (symbol-value 'whisper-language)))
        (call-interactively 'whisper-run))

    (defun vlv/whisper-run-english ()
        (interactive)
        (setopt whisper-language "en")
        (vlv/call-whisper-run-print-language))

    (defun vlv/whisper-run-portuguese ()
        (interactive)
        (setopt whisper-language "pt")
        (vlv/call-whisper-run-print-language))

    (defun vlv/whisper-run-french ()
        (interactive)
        (setopt whisper-language "fr")
        (vlv/call-whisper-run-print-language))

    (defun vlv/whisper-run-other-lang ()
        (interactive)
        (setopt whisper-language
            (read-string "Insert language to be used by whisper.cpp:"))
        (vlv/call-whisper-run-print-language))

    (map! :leader
        :prefix ("z" . "whisper")
        :desc "whisper-run" "z" #'whisper-run
        :desc "whisper-run" "e" #'vlv/whisper-run-english
        :desc "whisper-run" "f" #'vlv/whisper-run-french
        :desc "whisper-run" "o" #'vlv/whisper-run-other-lang
        :desc "whisper-run" "p" #'vlv/whisper-run-portuguese))
#+end_src

* Emacs Web Wowser EWW
** Configuration
#+begin_src emacs-lisp :tangle config.el
(use-package! eww
  :defer t
  :init
  (defun vlv/eww ()
    "Opens Emacs Web Wowser (EWW) in a new workspace."

    (interactive)
    (setq-local vlv-eww-workspace-name "EWW")
    (progn
        (+workspace-new vlv-eww-workspace-name)
        (+workspace-switch vlv-eww-workspace-name)
        (call-interactively 'eww)
        (delete-other-windows)))

  ;; TODO hook to kill workspace when quitting EWW if it's the only buffer in the workspace

  (map! :leader
        (:prefix ("o")
         :desc "EWW" "u" #'vlv/eww))

  :config
    (add-hook! 'eww-mode-hook 'olivetti-mode)
    (set-variable 'eww-bookmarks
                '((:url   "https://lars.ingebrigtsen.no/"
                    :title "Random Thoughts - Lars Ingebritsen")
                    (:url   "https://openlibrary.org/"
                    :title "Open Library"))))
#+end_src

* PDF
It can be quite disturbing to have a white background PDF displayed given that both OS and Emacs themes are consistently dark. Thankfully there's a pdf-view-mode function to set a dark colour scheme!

#+begin_src emacs-lisp :tangle config.el
(add-hook! 'pdf-view-mode-hook
           (pdf-view-midnight-minor-mode))
#+end_src
* ibuffer

#+begin_src emacs-lisp :tangle config.el
(use-package! ibuffer
  :defer t
  :config
  (map! :leader
        (:prefix ("b")
         :desc "Kill buffer and window" "K" #'kill-buffer-and-window)))
#+end_src

* hl-todo
** add warning to the highlighted words

#+begin_src emacs-lisp :tangle config.el
;; append the WARNING keyword to the keyword faces
(use-package! hl-todo
  :defer t
  :config
    (setopt hl-todo-keyword-faces (append hl-todo-keyword-faces '(("WARNING" warning bold))))

    ;; add warning to the base regex used by hl-todo
    (setopt hl-todo--regexp "\\(\\<\\(TODO\\|FIXME\\|REVIEW\\|HACK\\|DEPRECATED\\|NOTE\\|BUG\\|XXX\\|WARNING\\)\\>[:]*\\)"))
#+end_src
* Magit
#+begin_src emacs-lisp :tangle config.el
(use-package! magit
  :defer t
  :config
    (defun vlv/delete-merged-branches ()
    "Fetch prune then deletes branches already merged to a target branch.
Found in https://emacs.stackexchange.com/questions/60200/magit-remove-local-branches-that-were-merged-into-another-branch"
    (interactive)
    (magit-fetch-all-prune)
    (let* ((default-branch
            (read-string "Default branch: " (magit-get-current-branch)))
            (merged-branches
            (magit-git-lines "branch"
                            "--format" "%(refname:short)"
                            "--merged"
                            default-branch))
            (branches-to-delete
            (remove default-branch merged-branches)))
        (if branches-to-delete
            (if (yes-or-no-p (concat "Delete branches? ["
                                    (mapconcat 'identity branches-to-delete ", ") "]"))
                (magit-branch-delete branches-to-delete))
        (message "Nothing to delete"))))

    (transient-append-suffix 'magit-branch "C"
        '("K" "delete all merged" vlv/delete-merged-branches))

    (setopt magit-clone-always-transient t)

    (setopt magit-clone-default-directory (if (vlv-env-personal)
                                              "~/dev/"
                                            "D:/@Src/"))

    ;; add "develop" to magit long lived and main branch name lists.
    (add-to-list 'magit-long-lived-branches "develop")
    (add-to-list 'magit-main-branch-names "develop"))

(add-hook! 'magit-mode-hook 'olivetti-mode)
#+end_src

* Flyover :WIP:

Package that increases how flymake and flyckeck syntax checking.

There's some overlay with LSP errors and warnings (in rust at least), hence this is a WIP for now.
#+begin_src emacs-lisp :tangle no

(package! flyover
  :type 'core
  :recipe '(:host github
            :repo "konrad1977/flyover"))
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package! flyover
  :defer t
  :config
    ;; Enable flyover-mode globally
    (add-hook! 'flycheck-mode-hook #'flyover-mode)

    ;; Configure which error levels to display
    ;; Possible values: error, warning, info
    (setopt flyover-levels '(error warning info))

    ;; Use theme colors for error/warning/info faces
    (setopt flyover-use-theme-colors t)

    ;; Adjust background lightness (lower values = darker)
    (setopt flyover-background-lightness 45)

    ;; Make icon background darker than foreground
    (setopt flyover-percent-darker 40)

    ;; "Percentage to lighten or darken the text when tinting is enabled."
    (setopt flyover-text-tint-percent 50)

    ;; Choose which checkers to use (flycheck, flymake, or both)
    (setopt flyover-checkers '(flycheck flymake))

    ;; Enable debug messages
    (setopt flyover-debug nil))  ; Show all levels
#+end_src

* Markdown mode

#+begin_src emacs-lisp :tangle config.el
(add-hook! 'markdown-mode-hook 'olivetti-mode)
#+end_src

* info, help(ful) and documentation modes
#+begin_src emacs-lisp :tangle config.el
(add-hook! (list 'help-mode-hook
                 'helpful-mode-hook
                 'Info-mode-hook
                 'Man-mode-hook
                 'woman-mode-hook)
           #'olivetti-mode)
#+end_src

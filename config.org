* Introduction
Personal and work doom emacs config.
* Tasks
** DONE Add packages.el configuration here
** TODO Add init.el configuration here
*** [?] how to know about new flags and updates for modules if init.el content is here?
** TODO Make it one single config compatible with windows and linux
automatic environment detection
line endings, path to server file, etc. automatically configured
not installing packages that are not compatible with windows
*** IDEA use org tangling and enabling/disabling it via a function to detect the OS
#+begin_src emacs-lisp :tangle no
;; for linux only config:

(if (eq system-type 'gnu/linux)
    (setq tangle-path-linux config.el)
  (setq tangle-path-linux 'no)
  )

(if (eq system-type 'windows-nt)
    (setq tangle-path-win32 config.el)
  (setq tangle-path-win32 'no)
  )

#+end_src

* Doom
#+begin_src emacs-lisp :tangle config.el
(setq doom-theme 'doom-dark+)

(setq doom-font (font-spec :family "Fira Mono" :size 14))

;; This determines the style of line numbers in effect. If set to `nil', line
;; numbers are disabled. For relative line numbers, set this to `relative'.
(setq display-line-numbers-type t)

;; sets emacs general opacity
(doom/set-frame-opacity 97)
#+end_src

*  Emacs general configs
**  Save command minibuffer command history
#+begin_src emacs-lisp :tangle config.el
(setq user-full-name "Victor Lattaro Volpini"
      user-mail-address "victorlattaro@gmail.com")

(setq history-length 25)
(savehist-mode 1)
(add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src

**  Revert buffers when the underlying file has changed
#+begin_src emacs-lisp :tangle config.el
(global-auto-revert-mode 1)
;; Revert Dired and other buffers
(setq global-auto-revert-non-file-buffers t)
#+end_src

** Text editing
#+begin_src emacs-lisp :tangle config.el
;; Remember and restore the last cursor location of opened files
(save-place-mode 1)
#+end_src
* Org
** Basic config
#+begin_src emacs-lisp :tangle config.el
(setq org-directory "~/org/")
#+end_src
** Org Roam
Shortcuts are mapped with the SPC n r prefix by default.
#+begin_src emacs-lisp :tangle packages.el
(unpin! org-roam)
(package! org-roam-ui)
#+end_src

#+begin_src emacs-lisp :tangle config.el
(use-package! websocket
  :after org-roam)

(use-package! org-roam-ui
  :after org-roam ;; or :after org
  ;;         normally we'd recommend hooking orui after org-roam, but since org-roam does not have
  ;;         a hookable mode anymore, you're advised to pick something yourself
  ;;         if you don't care about startup time, use
  ;;  :hook (after-init . org-roam-ui-mode)
  :config
  (setq org-roam-ui-sync-theme t
        org-roam-ui-follow t
        org-roam-ui-update-on-save t
        org-roam-ui-open-on-start t)

  (map! :leader
        (:prefix ("n" . "org")
        (:prefix ("r" . "roam")
         :desc "Open org roam UI" "u" #'org-roam-ui-mode))
  ))
#+end_src

* Conda
#+begin_src emacs-lisp :tangle config.el
(use-package! conda
  :config
  (setq conda-anaconda-home (expand-file-name "~/miniconda3"))
  (setq conda-env-home-directory (expand-file-name "~/miniconda3"))
  (conda-env-initialize-interactive-shells)
  (conda-env-initialize-eshell))
#+end_src

* Projectile
Allow automatic recognition of projects given a list of paths.
#+begin_src emacs-lisp :tangle config.el
(use-package! projectile
  :config
  (setq projectile-project-search-path '("~/dev"))
  )
#+end_src

* Treemacs
#+begin_src emacs-lisp :tangle config.el
(after! treemacs
  (map! :leader
        (:prefix ("t" . "toggle")
         :desc "Toggle treemacs" "t" #'treemacs))
  )
#+end_src

* vterm
#+begin_src emacs-lisp :tangle config.el
(after! vterm
  (map! :leader
        (:prefix ("t" . "toggle")
         :desc "Toggle vterm" "v" #'+vterm/toggle))
  )
#+end_src

* dirvish
#+begin_src emacs-lisp :tangle config.el
(map! :leader
(:prefix ("t" . "toggle")
:desc "Toggle dirvish" "d" #'dirvish-side))

(setq dirvish-side-width 80)
#end_src

* YASNIPPET
#+begin_src emacs-lisp :tangle config.el
(defun yasnippet-extract-arg-and-type (arg)
  "Extract argument name and type from a string of the form 'arg: type'."
  (let* ((parts (split-string arg ": ")))
    (if (= (length parts) 2)
        (cons (car parts) (cadr parts))
      (cons (car parts) "type"))))

(defun yasnippet-python-params-doc (arg-string)
  "Generates a docstring for parameters in NumPy style with optional type annotations.
If there are no arguments, returns ''."
  (let* ((args (split-string arg-string ", "))
         (formatted-doc
          (if (string-blank-p arg-string)
              ""
            (mapconcat (lambda (arg)
                         (let* ((arg-pair (yasnippet-extract-arg-and-type arg))
                                (arg-name (car arg-pair))
                                (arg-type (cdr arg-pair)))
                           ;; TODO: Generate placeholders for each parameter description.
                           (format "%s : %s\n        TODO: Description of %s." arg-name arg-type arg-name)))
                       args
                       "\n    "))))
    formatted-doc))

(defun yasnippet-python-parameter-assignments (arg-string)
  "Convert a comma-separated string of arguments into self assignments.
If there are no arguments, returns 'pass'."
  (let* ((args (split-string arg-string ", "))
         (assignments
          (if (string-blank-p arg-string)
              "pass"
            (mapconcat (lambda (arg)
                         (let* ((parts (split-string arg ": "))
                                (name (car parts)))
                           (format "self.%s = %s" name name)))
                       args
                       "\n        "))))
    assignments))
#+end_src

** CC mode
*** LSP (clangd)
#+begin_src emacs-lisp :tangle config.el
(after! lsp-clangd
  (setq lsp-clients-clangd-args
        '("-j=3"
          "--background-index"
          "--clang-tidy"
          "--completion-style=detailed"
          "--header-insertion=never"
          "--header-insertion-decorators=0"))
  (set-lsp-priority! 'clangd 2))
#+end_src
*** CMAKE-IDE
[[https://github.com/Fox7Fog/emacs-cmake-ide][GitHub - Fox7Fog/emacs-cmake-ide: Use Emacs as a C/C++ IDE]]
#+begin_src emacs-lisp :tangle packages.el
(package! cmake-ide)
#+end_src

#+begin_src emacs-lisp :tangle config.el
(cmake-ide-setup)
#+end_src

*** TODO Fine tune LSP flags
* LLM support
** gptel installation
#+begin_src emacs-lisp :tangle packages.el
(package! gptel)
#+end_src
*** Keybindings
#+begin_src emacs-lisp :tangle config.el
(after! gptel
  (map! :leader
        (:prefix ("l" . "gptel")
         :desc "menu" "l" #'gptel-menu
         :desc "send" "s" #'gptel-send
         :desc "open prompt" "p" #'gptel
         :desc "abort" "A" #'gptel-abort
         :desc "add file to context" "a" #'gptel-add-file
         )
  )
  ;; window to scroll automatically as the response is inserted
  (add-hook 'gptel-post-stream-hook 'gptel-auto-scroll)
  ;; make cursor to move to the next prompt after the response is inserted
  (add-hook 'gptel-post-response-functions 'gptel-end-of-response)
)
#+end_src

*** ollama
added only two models that this machine can run
#+begin_src emacs-lisp :tangle config.el
;; default model
(setq gptel-model 'llama3.1:8b)

;; adding Ollama backend
(setq gptel-backend (gptel-make-ollama "Ollama"
        :host "localhost:11434"
        :stream t
        :models '((llama3.1:8b) (llama3.2:3b) (qwen2.5-coder))))
#+end_src
**** Spawning process
#+begin_src emacs-lisp :tangle config.el
(defun vlv/spawn-ollama-process ()
  "Starts an Ollama server process in the background if there's not already one.

This function runs the `ollama` command with the argument 'serve' to start a server
process. The process is started in the background and does not block Emacs.

Note: This function assumes that you have installed and configured Ollama properly."

  (interactive)

  (if (eq (process-status "ollama") 'run)
        (message "Ollama server is already running")
    )
        (start-process "ollama" "ollama-serve-process" "ollama" "serve")
 )
#+end_src

**** Killing process
#+begin_src emacs-lisp :tangle config.el
(defun vlv/kill-ollama-process ()
  "Kills the running ollama processes.

Assumes the ollama process is named 'ollama-serve-process'."


  (interactive)
        (kill-process "ollama-serve-process")
 )
#+end_src
** Process management
**** Spawning a terminal process
#+begin_src emacs-lisp :tanble config.el
(defvar watch-history nil)
(defun vlv/watch (command &optional name)
  "Runs \"watch COMMAND\" in a `term' buffer.  \"q\" to exit."
  (interactive
   (list (read-from-minibuffer "watch " nil nil nil 'watch-history)))
  (let* ((name (or name (concat "watch " command)))
         (switches (split-string-and-unquote command))
         (termbuf (apply 'make-term name "watch" nil switches))
         (proc (get-buffer-process termbuf)))
    (set-buffer termbuf)
    (term-mode)
    (term-char-mode)
    (setq show-trailing-whitespace nil)
    ;; Kill the process interactively with "q".
    (set-process-query-on-exit-flag proc nil)
    (let ((map (make-sparse-keymap))
          (cmdquit (make-symbol "watch-quit")))
      (put cmdquit 'function-documentation "Kill the `watch' buffer.")
      (put cmdquit 'interactive-form '(interactive))
      (fset cmdquit (apply-partially 'kill-process proc))
      (set-keymap-parent map (current-local-map))
      (define-key map (kbd "q") cmdquit)
      (use-local-map map))
    ;; Kill the buffer automatically when the process is killed.
    (set-process-sentinel
     proc (lambda (process signal)
            (and (memq (process-status process) '(exit signal))
                 (buffer-live-p (process-buffer process))
                 (kill-buffer (process-buffer process)))))
    ;; Display the buffer.
    (switch-to-buffer termbuf)))

#+end_src
***** TODO open window after calling int
***** TODO go to new window once its opened
***** TODO make window killable using "q"

**** Spawning nvidia smi watch process
#+begin_src emacs-lisp :tangle no
(defun vlv/open-nvidia-performance_tracker ()
  "Starts a process to display NVIDIA GPU data.

Spaws a child process using UNIX watch command using nvidia-smi command."

  (interactive)
  (vlv/watch "-n0.1 nvidia-smi")
 )
#+end_src
***** TODO FIXME
* bug-hunter
#+begin_src emacs-lisp :tangle packages.el
(package! bug-hunter)
#+end_src

* RSS feed
** Setting up feeds
By default, the feeds and their corresponding tags are described in[[file:~/org/elfeed.org][
~/org/elfeed.org]].
*** TODO automatically set up feeds
Two trivial ways to do it:
- Add the elfeed.org file to .dotfiles and use GNU Stow to symlink it to the
  right place
- Use org tangle to create and update it
  Tried using babel code blocks with org, it did not work at all.
** Basic elfeed configuration.
#+begin_src emacs-lisp :tangle config.el
;; global mapping
(map! :leader
      (:prefix ("e" . "elfeed")
       :desc "Enter elfeed" "e" #'elfeed
       :desc "Update all feeds" "u" #'elfeed-update))

(after! elfeed
  ;; the basic value cuts a part of the feed's title.
  ;; Increasing the column width fixes it.
  (setq elfeed-goodies/feed-source-column-width 20)

)
#+end_src

** Removing items from the feed
Strangely, elfeed does not allow us to delete entries that we don't want to see
in the feed anymore. Moreover, when a feed is deleted, its entries are not
removed from the feed.

A solution is proposed by [[https://github.com/skeeto/elfeed/issues/392][skeeto/elfeed#392 Deleting feeds with all their
entries]], it works by deleting selected items feed from elfeed's database.
#+begin_src emacs-lisp :tangle config.el
(defun sk/elfeed-db-remove-entry (id)
  "Removes the entry for ID"
  (avl-tree-delete elfeed-db-index id)
  (remhash id elfeed-db-entries))

(defun sk/elfeed-search-remove-selected ()
  "Remove selected entries from database"
  (interactive)
  (let* ((entries (elfeed-search-selected))
	 (count (length entries)))
    (when (y-or-n-p (format "Delete %d entires?" count))
      (cl-loop for entry in entries
	       do (sk/elfeed-db-remove-entry (elfeed-entry-id entry)))))
  (elfeed-search-update--force))
#+end_src
* Completions
** Corfu
#+begin_src emacs-lisp :tangle config.el
(use-package! corfu
  :config
  (defun corfu-enable-in-minibuffer ()
    "Enable Corfu in the minibuffer if `completion-at-point' is bound."
    (when (where-is-internal #'completion-at-point (list (current-local-map)))
      ;; (setq-local corfu-auto nil) ;; Enable/disable auto completion
      (setq-local corfu-echo-delay nil ;; Disable automatic echo and popup
                  corfu-popupinfo-delay nil)
      (corfu-mode 1)))
  (add-hook 'minibuffer-setup-hook #'corfu-enable-in-minibuffer))
#+end_src
** TODO Consult-omni
[[https://github.com/armindarvish/consult-omni?tab=readme-ov-file#drop-in-example-config][GitHub - armindarvish/consult-omni: A Powerful Versatile Omni Search inside E...]]

"consult-omni is a package for getting search results from one or several custom
sources (web search engines, AI assistants, elfeed database, org notes, local
files, desktop applications, mail servers, …) directly in Emacs minibuffer. It
is a successor of consult-web, with expanded features and functionalities."

It still in its beta phase, having its first release in July 24'.

Some security concerns arise due to using emacs as a web browser... This is to
be tested and tracked over time. The project seems nevertheless extremely
promising and would bring plenty of nice features to the config.

Tangling will be left disabled for now, but this can be a starting point for the future.
#+begin_src emacs-lisp :tangle packages.el
(package! consult-omni
  :type 'core
  :recipe '(:host github
            :repo "armindarvish/consult-omni"
            :branch "main"
            :files (:defaults "sources/*.el")))
#+end_src

When installing this, somehow it broke org table in a strange way, the GUI was jittering and error messages coming in non-stop. To be investigated !
#+begin_src emacs-lisp :tangle config.el
(use-package! consult-omni
  :after consult
  :custom
   ;; General settings that apply to all sources
  (consult-omni-show-preview t) ;;; show previews
  (consult-omni-preview-key "C-o") ;;; set the preview key to C-o
  :config
  ;; Load Sources Core code
  (require 'consult-omni-sources)
  ;; Load Embark Actions
  (require 'consult-omni-embark)

  ;; Either load all source modules or a selected list

  ;;; Select a list of modules you want to aload, otherwise all sources all laoded
  (setq consult-omni-sources-modules-to-load (list 'consult-omni-wkipedia 'consult-omni-notes 'consult-omni-gptel))
  (consult-omni-sources-load-modules)
  ;;; set multiple sources for consult-omni-multi command. Change these lists as needed for different interactive commands. Keep in mind that each source has to be a key in `consult-omni-sources-alist'.
  (setq consult-omni-multi-sources '("calc"
                                     "File"
                                     "Buffer"
                                     ;; "Bookmark"
                                     "Apps"
                                     "gptel"
                                     "Brave"
                                     "Dictionary"
                                     "Google"
                                     "Wikipedia"
                                     "elfeed"
                                     ;; "mu4e"
                                     "buffers text search"
                                     "Notes Search"
                                     "Org Agenda"
                                     "GitHub"
                                     "YouTube"
                                     "Invidious"))

;; Per source customization

  ;;; Set API KEYs. It is recommended to use a function that returns the string for better security.
  ;; (setq consult-omni-google-customsearch-key "YOUR-GOOGLE-API-KEY-OR-FUNCTION")
  ;; (setq consult-omni-google-customsearch-cx "YOUR-GOOGLE-CX-NUMBER-OR-FUNCTION")
  ;; (setq consult-omni-brave-api-key "YOUR-BRAVE-API-KEY-OR-FUNCTION")
  ;; (setq consult-omni-stackexchange-api-key "YOUR-STACKEXCHANGE-API-KEY-OR-FUNCTION")
  ;; (setq consult-omni-pubmed-api-key "YOUR-PUBMED-API-KEY-OR-FUNCTION")
  ;; (setq consult-omni-openai-api-key "YOUR-OPENAI-API-KEY-OR-FUNCTION")

;;; Pick you favorite autosuggest command.
  (setq consult-omni-default-autosuggest-command #'consult-omni-dynamic-brave-autosuggest) ;;or any other autosuggest source you define

 ;;; Set your shorthand favorite interactive command
  (setq consult-omni-default-interactive-command #'consult-omni-multi))
* Email client
Using mu4e with mbsync as backend usage.

A bug in ubuntu-based distros causes that whenever there's a reinstall of mu, it does not get properly reinstalled, so it must be added to the load path by hand.

The installation process is a bit unclear in doom's documentation, but there are a few steps and dependencies to install in order to use mu4e in emacs.

** Prerequisites
*** Tasks
**** DONE Make it work one time
**** TODO document installation of external programs
***** TODO mu
***** TODO mbsync
**** TODO make script to handle the installation
*** mu
Mu is a mail indexer. It's job is to make sense of a mail database stored locally.
The version that's available using apt is not really functional as of 16/11/24. What worked was to download the tarball from the repo itself, compile and add it to the path.
#+begin_src emacs-lisp :tangle config.el
(add-to-list 'load-path "/usr/share/emacs/site-lisp/mu4e")
#+end_src
*** mbsync
This is the machinery to fetch mail from an IMAP server.

** Configuration

#+begin_src emacs-lisp :tangle config.el
;; Each path is relative to the path of the maildir you passed to mu

;; (setq mu4e-get-mail-command "mbsync gmail"
;;       ;; get emails and index every 5 minutes
;;       mu4e-update-interval 300
;; 	  ;; send emails with format=flowed
;; 	  mu4e-compose-format-flowed t
;; 	  ;; no need to run cleanup after indexing for gmail
;; 	  mu4e-index-cleanup nil
;; 	  mu4e-index-lazy-check t
;;       ;; more sensible date format
;;       mu4e-headers-date-format "%d.%m.%y")

(set-email-account! "@gmail.com"
  '((mu4e-sent-folder       . "/gmail/Sent Mail")
    (mu4e-drafts-folder     . "/gmail/Drafts")
    (mu4e-trash-folder      . "/gmail/Trash")
    (mu4e-refile-folder     . "/gmail/All Mail")
    (smtpmail-smtp-user     . "victorlattaro@gmail.com")
    (mu4e-compose-signature . "---\nVictor Lattaro Volpini"))
  )
;; if "gmail" is missing from the address or maildir, the account must be
;; specified manually in `+mu4e-gmail-accounts':
(setq +mu4e-gmail-accounts '(("victorlattaro@gmail.com" . "/victorlattaro")))

;; Each path is relative to the path of the maildir you passed to mu
(setq mu4e-index-cleanup nil
      ;; because gmail uses labels as folders we can use lazy check since
      ;; messages don't really "move"
      mu4e-index-lazy-check t)
#+end_src
